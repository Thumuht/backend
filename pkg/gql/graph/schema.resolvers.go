package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.29

import (
	"backend/pkg/db"
	"backend/pkg/gql/graph/model"
	"backend/pkg/utils"
	"context"
	"time"

	"golang.org/x/crypto/bcrypt"
)

// CreateUser is the resolver for the createUser field.
func (r *mutationResolver) CreateUser(ctx context.Context, input model.NewUser) (*db.User, error) {
	pw, err := bcrypt.GenerateFromPassword([]byte(input.Password), 0)
	if err != nil {
		return nil, err
	}

	user := &db.User{
		LoginName: input.LoginName,
		Password:  string(pw),
	}

	_, err = r.DB.NewInsert().Model(user).Returning("*").Exec(ctx)
	if err != nil {
		return nil, err
	}

	return user, nil
}

// CreatePost is the resolver for the createPost field.
func (r *mutationResolver) CreatePost(ctx context.Context, input model.NewPost) (*db.Post, error) {
	post := &db.Post{
		UserID:  int32(input.UserID),
		Content: *input.Content,
		Title:   *input.Title,
	}
	_, err := r.DB.NewInsert().Model(post).Returning("*").Exec(ctx)
	if err != nil {
		return nil, err
	}
	return post, nil
}

// CreateComment is the resolver for the createComment field.
func (r *mutationResolver) CreateComment(ctx context.Context, input model.NewComment) (*db.Comment, error) {
	comment := &db.Comment{
		UserID:  int32(input.UserID),
		PostID:  int32(input.PostID),
		Content: *input.Content,
	}
	_, err := r.DB.NewInsert().Model(comment).Returning("*").Exec(ctx)
	if err != nil {
		return nil, err
	}
	return comment, nil
}

// FollowUser is the resolver for the followUser field.
func (r *mutationResolver) FollowUser(ctx context.Context, input int) (bool, error) {
	gctx, err := utils.GinContextFromContext(ctx)
	if err != nil {
		return false, err
	}

	_, err = r.DB.NewInsert().Model(&db.Follow{
		FollowFromId: int32(gctx.GetInt("userId")), // me
		FollowToId:   int32(input),
	}).Exec(ctx)

	if err != nil {
		return false, err
	}

	return true, nil
}

// DeleteUser is the resolver for the deleteUser field.
func (r *mutationResolver) DeleteUser(ctx context.Context, input int) (bool, error) {
	_, err := r.DB.NewDelete().Model((*db.User)(nil)).Where("user_id = ?", input).Exec(ctx)
	if err != nil {
		return false, err
	}
	return true, nil
}

// DeletePost is the resolver for the deletePost field.
func (r *mutationResolver) DeletePost(ctx context.Context, input int) (bool, error) {
	_, err := r.DB.NewDelete().Model((*db.Post)(nil)).Where("post_id = ?", input).Exec(ctx)
	if err != nil {
		return false, err
	}
	return true, nil
}

// DeleteComment is the resolver for the deleteComment field.
func (r *mutationResolver) DeleteComment(ctx context.Context, input int) (bool, error) {
	_, err := r.DB.NewDelete().Model((*db.Comment)(nil)).Where("comment_id = ?", input).Exec(ctx)
	if err != nil {
		return false, err
	}
	return true, nil
}

// UpdatePost is the resolver for the updatePost field.
func (r *mutationResolver) UpdatePost(ctx context.Context, input model.UpdatePost) (*db.Post, error) {
	post := &db.Post{
		ID:        int32(input.PostID),
		UpdatedAt: time.Now(),
	}

	if input.Content != nil {
		post.Content = *input.Content
	}

	if input.Title != nil {
		post.Title = *input.Title
	}

	_, err := r.DB.NewUpdate().Model(post).OmitZero().WherePK().Returning("*").Exec(ctx)
	if err != nil {
		return nil, err
	}
	return post, nil
}

// UpdateComment is the resolver for the updateComment field.
func (r *mutationResolver) UpdateComment(ctx context.Context, input model.UpdateComment) (*db.Comment, error) {
	comment := &db.Comment{
		ID:        int32(input.CommentID),
		UpdatedAt: time.Now(),
	}

	if input.Content != nil {
		comment.Content = *input.Content
	}
	_, err := r.DB.NewUpdate().Model(comment).OmitZero().WherePK().Returning("*").Exec(ctx)
	if err != nil {
		return nil, err
	}
	return comment, nil
}

// LikePost is the resolver for the likePost field.
func (r *mutationResolver) LikePost(ctx context.Context, input int) (bool, error) {
	// first see cache
	// if not exists, fetch from db and write to cache
	r.Mutex.Lock()
	defer r.Mutex.Unlock()

	if like, ok := r.Cache.PostLike.Get(input); ok {
		r.Cache.PostLike.Set(input, *like+1)
	} else {
		var post db.Post
		err := r.DB.NewSelect().Model(&post).Where("post_id = ?", input).Scan(ctx)
		if err != nil {
			return false, err
		}
		r.Cache.PostLike.Set(input, int(post.Like)+1)
	}

	return true, nil
}

// LikeComment is the resolver for the likeComment field.
func (r *mutationResolver) LikeComment(ctx context.Context, input int) (bool, error) {
	// first see cache
	// if not exists, fetch from db and write to cache
	r.Mutex.Lock()
	defer r.Mutex.Unlock()

	if like, ok := r.Cache.CommentLike.Get(input); ok {
		r.Cache.CommentLike.Set(input, *like+1)
	} else {
		var comment db.Comment
		err := r.DB.NewSelect().Model(&comment).Where("comment_id = ?", input).Scan(ctx)
		if err != nil {
			return false, err
		}
		r.Cache.CommentLike.Set(input, int(comment.Like)+1)
	}

	return true, nil
}

// NewBookmarkList is the resolver for the newBookmarkList field.
func (r *mutationResolver) NewBookmarkList(ctx context.Context, input string) (*db.BookmarkList, error) {
	gctx, err := utils.GinContextFromContext(ctx)
	if err != nil {
		return nil, err
	}
	cTime := time.Now()
	bookmarkList := &db.BookmarkList{
		List:       input,
		UserID:     int32(gctx.GetInt("userId")),
		CreatedAt:  cTime,
		UpdatedAt:  cTime,
	}
	_, err = r.DB.NewInsert().Model(bookmarkList).Returning("*").Exec(ctx)
	if err != nil {
		return nil, err
	}
	return bookmarkList, nil
}

// MarkPost is the resolver for the markPost field.
func (r *mutationResolver) MarkPost(ctx context.Context, input model.NewMarkPost) (bool, error) {
	markPost := &db.Bookmark{
		PostID:     int32(input.PostID),
		BookmarkListID:     int32(input.BookmarkListID),
	}
	_, err := r.DB.NewInsert().Model(markPost).Returning("*").Exec(ctx)
	if err != nil {
		return false, err
	}
	return true, nil
}

// Users is the resolver for the users field.
func (r *queryResolver) Users(ctx context.Context, input model.GetUserInput) ([]db.User, error) {
	var users []db.User
	err := r.DB.NewSelect().Model(&users).Relation("Post").Relation("Comment").
		Order(input.OrderBy.String() + " " + input.Order.String()).Limit(input.Limit).
		Offset(input.Offset).
		Scan(ctx)
	if err != nil {
		return nil, err
	}

	return users, nil
}

// Posts is the resolver for the posts field.
func (r *queryResolver) Posts(ctx context.Context, input model.GetPostInput) ([]db.Post, error) {
	var posts []db.Post
	err := r.DB.NewSelect().Model(&posts).Relation("User").Relation("Comment").Relation("Attachment").
		Order(input.OrderBy.String() + " " + input.Order.String()).Limit(input.Limit).
		Offset(input.Offset).Scan(ctx)

	if err != nil {
		return nil, err
	}

	// range is a copy..
	for i := range posts {
		if like, ok := r.Cache.PostLike.Get(int(posts[i].ID)); ok {
			posts[i].Like = int32(*like)
		}
		if view, ok := r.Cache.PostView.Get(int(posts[i].ID)); ok {
			posts[i].Like = int32(*view)
		}
	}

	return posts, nil
}

// PostDetail is the resolver for the postDetail field.
func (r *queryResolver) PostDetail(ctx context.Context, input int) (*db.Post, error) {
	var post db.Post

	r.Mutex.Lock()
	defer r.Mutex.Unlock()

	err := r.DB.NewSelect().Model(&post).Relation("Comment").Relation("Attachment").Relation("User").Where("post_id = ?", input).Scan(ctx)
	if err != nil {
		return nil, err
	}

	// first see cache
	// if not exists, fetch from db and write to cache
	if view, ok := r.Cache.PostView.Get(input); ok {
		post.View = int32(*view) + 1
	} else {
		post.View += 1
	}

	if like, ok := r.Cache.PostLike.Get(input); ok {
		post.Like = int32(*like)
	}

	r.Cache.PostView.Set(input, int(post.View))
	return &post, nil
}

// Comment is the resolver for the comment field.
func (r *queryResolver) Comment(ctx context.Context, input model.GetCommentInput) ([]db.Comment, error) {
	var comments []db.Comment
	err := r.DB.NewSelect().Model(&comments).Relation("Post").Relation("User").Relation("Attachment").
		Order(input.OrderBy.String() + " " + input.Order.String()).Limit(input.Limit).
		Offset(input.Offset).Scan(ctx)
	if err != nil {
		return nil, err
	}

	for i := range comments {
		if like, ok := r.Cache.PostLike.Get(int(comments[i].ID)); ok {
			comments[i].Like = int32(*like)
		}
	}

	return comments, nil
}

// Follow is the resolver for the follow field.
func (r *userResolver) Follow(ctx context.Context, obj *db.User) ([]*db.User, error) {
	// find all user that obj follows
	var users []*db.User
	err := r.DB.NewSelect().Model(&users).Relation("Post").Relation("Comment").
		Where("user_id IN (SELECT follow_id FROM follow WHERE user_id = ?)", obj.ID).Scan(ctx)
	if err != nil {
		return nil, err
	}
	return users, nil
}

// Follower is the resolver for the follower field.
func (r *userResolver) Follower(ctx context.Context, obj *db.User) ([]*db.User, error) {
	// follow all user that follows obj
	var users []*db.User
	err := r.DB.NewSelect().Model(&users).Relation("Post").Relation("Comment").
		Where("user_id IN (SELECT user_id FROM follow WHERE follow_id = ?)", obj.ID).Scan(ctx)
	if err != nil {
		return nil, err
	}
	return users, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// User returns UserResolver implementation.
func (r *Resolver) User() UserResolver { return &userResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type userResolver struct{ *Resolver }
