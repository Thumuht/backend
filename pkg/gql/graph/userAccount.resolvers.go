package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.31

import (
	"backend/pkg/db"
	"backend/pkg/gql/graph/model"
	"backend/pkg/utils"
	"context"
	"fmt"

	"golang.org/x/crypto/bcrypt"
)

// MessageID is the resolver for the messageId field.
func (r *messageResolver) MessageID(ctx context.Context, obj *db.Message) (int, error) {
	return int(obj.ID), nil
}

// CreateUser is the resolver for the createUser field.
func (r *mutationResolver) CreateUser(ctx context.Context, input model.NewUser) (*db.User, error) {
	pw, err := bcrypt.GenerateFromPassword([]byte(input.Password), 0)
	if err != nil {
		return nil, err
	}

	user := &db.User{
		LoginName: input.LoginName,
		Password:  string(pw),
	}

	_, err = r.DB.NewInsert().Model(user).Returning("*").Exec(ctx)
	if err != nil {
		return nil, err
	}

	if r.sendMsgTo(ctx, "welcome to thumuht, new user!", utils.SysAccountID, int(user.ID)) != nil {
		return nil, fmt.Errorf("failed to send message")
	}

	return user, nil
}

// FollowUser is the resolver for the followUser field.
func (r *mutationResolver) FollowUser(ctx context.Context, input int) (bool, error) {
	userTok, err := utils.GetMe(ctx)
	if err != nil {
		return false, err
	}

	userId, _ := r.Cache.Sessions.Get(userTok)

	_, err = r.DB.NewInsert().Model(&db.Follow{
		FollowFromId: int32(*userId), // me
		FollowToId:   int32(input),
	}).Exec(ctx)

	if err != nil {
		return false, err
	}

	return true, nil
}

// UnfollowUser is the resolver for the unfollowUser field.
func (r *mutationResolver) UnfollowUser(ctx context.Context, input int) (bool, error) {
	meTok, err := utils.GetMe(ctx)
	if err != nil {
		return false, err
	}

	meId, _ := r.Cache.Sessions.Get(meTok)

	_, err = r.DB.NewDelete().Model((*db.Follow)(nil)).
		Where("follow_from_id = ?", *meId).
		Where("follow_to_id = ?", input).
		Exec(ctx)

	if err != nil {
		return false, err
	}

	return true, nil
}

// DeleteUser is the resolver for the deleteUser field.
func (r *mutationResolver) DeleteUser(ctx context.Context, input int) (bool, error) {
	_, err := r.DB.NewDelete().Model((*db.User)(nil)).Where("user_id = ?", input).Exec(ctx)
	if err != nil {
		return false, err
	}
	return true, nil
}

// UpdateUser is the resolver for the updateUser field.
func (r *mutationResolver) UpdateUser(ctx context.Context, input model.UpdateUser) (*db.User, error) {
	// get userId from context
	userTok, err := utils.GetMe(ctx)
	if err != nil {
		return nil, err
	}

	userId, _ := r.Cache.Sessions.Get(userTok)

	user := &db.User{
		ID: int32(*userId),
	}

	if input.Nickname != nil {
		user.Nickname = *input.Nickname
	}

	if input.Password != nil {
		pw, err := bcrypt.GenerateFromPassword([]byte(*input.Password), 0)
		if err != nil {
			return nil, err
		}
		user.Password = string(pw)
	}

	if input.Email != nil {
		user.Email = *input.Email
	}

	if input.About != nil {
		user.About = *input.About
	}

	if input.Avatar != nil {
		user.Avatar = *input.Avatar
	}

	_, err = r.DB.NewUpdate().Model(user).OmitZero().Returning("*").
		Where("user_id = ?", user.ID).Exec(ctx)
	if err != nil {
		return nil, err
	}
	return user, nil
}

// BlockUser is the resolver for the blockUser field.
func (r *mutationResolver) BlockUser(ctx context.Context, input int) (bool, error) {
	meTok, err := utils.GetMe(ctx)
	if err != nil {
		return false, err
	}

	meId, _ := r.Cache.Sessions.Get(meTok)

	_, err = r.DB.NewInsert().Model(&db.Block{
		BlockFromId: int32(*meId),
		BlockToId:   int32(input),
	}).Exec(ctx)

	if err != nil {
		return false, err
	}

	return true, nil
}

// UnblockUser is the resolver for the unblockUser field.
func (r *mutationResolver) UnblockUser(ctx context.Context, input int) (bool, error) {
	meTok, err := utils.GetMe(ctx)
	if err != nil {
		return false, err
	}

	meId, _ := r.Cache.Sessions.Get(meTok)

	_, err = r.DB.NewDelete().Model((*db.Block)(nil)).
		Where("block_from_id = ?", *meId).
		Where("block_to_id = ?", input).
		Exec(ctx)

	if err != nil {
		return false, err
	}

	return true, nil
}

// SendMessage is the resolver for the sendMessage field.
func (r *mutationResolver) SendMessage(ctx context.Context, input model.MessageInput) (bool, error) {
	meTok, err := utils.GetMe(ctx)
	if err != nil {
		return false, err
	}

	meId, _ := r.Cache.Sessions.Get(meTok)

	if r.sendMsgTo(ctx, input.Content, *meId, input.ToID) != nil {
		return false, err
	}

	return true, nil
}

// Login is the resolver for the login field.
func (r *mutationResolver) Login(ctx context.Context, input model.LoginSession) (*model.LoginInfo, error) {
	var user db.User

	err := r.DB.NewSelect().Model(&user).Where("login_name = ?", input.LoginName).Scan(ctx)
	if err != nil {
		return nil, err
	}

	if err := bcrypt.CompareHashAndPassword([]byte(user.Password), []byte(input.Password)); err != nil {
		return nil, fmt.Errorf("login %s %s, input pw %s %w", input.LoginName, user.Password, input.Password, err)
	}

	token := utils.GenToken()
	r.Cache.Sessions.Set(token, int(user.ID))

	// query all new message from db, and send to user
	var msgs []db.Message
	err = r.DB.NewSelect().Model(&msgs).Where("user_to = ?", user.ID).Where("is_new = ?", true).Scan(ctx)
	if err != nil {
		return nil, err
	}

	if ch, ok := r.Cache.Notifier.Get(int(user.ID)); ok {
		for _, msg := range msgs {
			*ch <- &msg
		}
	} else {
		// if user didn't login, new a channel and put all new message in it
		ch := make(chan *db.Message, 10)
		r.Cache.Notifier.Set(int(user.ID), ch)
		for _, msg := range msgs {
			ch <- &msg
		}
	}

	// update them as not new
	_, err = r.DB.NewUpdate().Model((*db.Message)(nil)).Set("is_new = ?", false).
		Where("user_to = ?", user.ID).Where("is_new = ?", true).Exec(ctx)
	if err != nil {
		return nil, err
	}

	return &model.LoginInfo{
		Token:  token,
		UserID: int(user.ID),
	}, nil
}

// Logout is the resolver for the logout field.
func (r *mutationResolver) Logout(ctx context.Context) (bool, error) {
	userTok, _ := utils.GetMe(ctx)

	userId, _ := r.Cache.Sessions.Get(userTok)

	r.Cache.Notifier.Remove(*userId)

	return true, r.Cache.Sessions.Remove(userTok)
}

// Users is the resolver for the users field.
func (r *queryResolver) Users(ctx context.Context, input model.GetUserInput) ([]db.User, error) {
	var users []db.User
	err := r.DB.NewSelect().Model(&users).Relation("Post").Relation("Comment").Relation("Follow").Relation("Block").Relation("Follower").
		Order(input.OrderBy.String() + " " + input.Order.String()).Limit(input.Limit).
		Offset(input.Offset).
		Scan(ctx)
	if err != nil {
		return nil, err
	}

	return users, nil
}

// GetUserByID is the resolver for the getUserById field.
func (r *queryResolver) GetUserByID(ctx context.Context, input int) (*db.User, error) {
	var user db.User
	err := r.DB.NewSelect().Model(&user).Where("user_id = ?", input).Scan(ctx)
	if err != nil {
		return nil, err
	}
	return &user, nil
}

// GetUserFavoritePost is the resolver for the getUserFavoritePost field.
func (r *queryResolver) GetUserFavoritePost(ctx context.Context, input int) ([]*db.Post, error) {
	var favPosts []*db.Post
	_ = r.DB.NewSelect().Model(&favPosts).Where("post_id IN (SELECT bookmark_post_id FROM bookmark WHERE bookmark_user_id = ?)", input, input).Scan(ctx)
	return favPosts, nil
}

// Me is the resolver for the me field.
func (r *queryResolver) Me(ctx context.Context) (*db.User, error) {
	meTok, err := utils.GetMe(ctx)
	if err != nil {
		return nil, err
	}

	meId, _ := r.Cache.Sessions.Get(meTok)

	var user db.User
	err = r.DB.NewSelect().Model(&user).Where("user_id = ?", *meId).Scan(ctx)
	if err != nil {
		return nil, err
	}
	return &user, nil
}

// MyMessage is the resolver for the myMessage field.
func (r *queryResolver) MyMessage(ctx context.Context, from *int, offset *int, limit *int) ([]db.Message, error) {
	// if from = nil, get all message
	meTok, err := utils.GetMe(ctx)
	if err != nil {
		return nil, err
	}

	meId, _ := r.Cache.Sessions.Get(meTok)

	var msgs []db.Message
	q := r.DB.NewSelect().Model(&msgs).Where("user_to = ? OR user_from = ?", *meId, *meId).
		Order("created_at DESC")
	if from != nil {
		q = q.Where("user_from = ?", *from)
	}
	err = q.Offset(*offset).Limit(*limit).Scan(ctx)
	if err != nil {
		return nil, err
	}
	return msgs, nil
}

// MessageNum is the resolver for the messageNum field.
func (r *queryResolver) MessageNum(ctx context.Context, from int) (int, error) {
	// count from message where user_from = from and user_to = me
	meTok, err := utils.GetMe(ctx)
	if err != nil {
		return 0, err
	}

	meId, _ := r.Cache.Sessions.Get(meTok)

	var num int
	num, err = r.DB.NewSelect().Model((*db.Message)(nil)).Where("user_from = ?", from).Where("user_to = ?", *meId).Count(ctx)
	if err != nil {
		return 0, err
	}
	return num, nil
}

// MyMessageUser is the resolver for the myMessageUser field.
func (r *queryResolver) MyMessageUser(ctx context.Context) ([]db.User, error) {
	// select distinct users from message
	meTok, err := utils.GetMe(ctx)
	if err != nil {
		return nil, err
	}

	meId, _ := r.Cache.Sessions.Get(meTok)

	var users []db.User
	err = r.DB.NewSelect().Model(&users).Relation("Post").Relation("Comment").
		Where("user_id IN (SELECT DISTINCT user_from FROM message WHERE user_to = ? OR user_from = ?)", *meId, *meId).
		Scan(ctx)
	if err != nil {
		return nil, err
	}
	return users, nil
}

// Follow is the resolver for the follow field.
func (r *userResolver) Follow(ctx context.Context, obj *db.User) ([]*db.User, error) {
	// find all user that obj follows
	var users []*db.User
	err := r.DB.NewSelect().Model(&users).Relation("Post").Relation("Comment").
		Where("user_id IN (SELECT follow_id FROM follow WHERE user_id = ?)", obj.ID).Scan(ctx)
	if err != nil {
		return nil, err
	}
	return users, nil
}

// Follower is the resolver for the follower field.
func (r *userResolver) Follower(ctx context.Context, obj *db.User) ([]*db.User, error) {
	// follow all user that follows obj
	var users []*db.User
	err := r.DB.NewSelect().Model(&users).Relation("Post").Relation("Comment").
		Where("user_id IN (SELECT user_id FROM follow WHERE follow_id = ?)", obj.ID).Scan(ctx)
	if err != nil {
		return nil, err
	}
	return users, nil
}

// Block is the resolver for the block field.
func (r *userResolver) Block(ctx context.Context, obj *db.User) ([]*db.User, error) {
	// find all user that obj blocks
	var users []*db.User
	err := r.DB.NewSelect().Model(&users).Relation("Post").Relation("Comment").
		Where("user_id IN (SELECT block_to_id FROM block WHERE block_from = ?)", obj.ID).Scan(ctx)
	if err != nil {
		return nil, err
	}
	return users, nil
}

// Message returns MessageResolver implementation.
func (r *Resolver) Message() MessageResolver { return &messageResolver{r} }

// User returns UserResolver implementation.
func (r *Resolver) User() UserResolver { return &userResolver{r} }

type messageResolver struct{ *Resolver }
type userResolver struct{ *Resolver }
