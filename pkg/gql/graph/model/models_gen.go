// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package model

import (
	"fmt"
	"io"
	"strconv"

	"github.com/99designs/gqlgen/graphql"
)

type GetCommentInput struct {
	Limit   int            `json:"limit"`
	Offset  int            `json:"offset"`
	OrderBy CommentOrderBy `json:"orderBy"`
	Order   Order          `json:"order"`
}

type GetPostInput struct {
	Limit   int         `json:"limit"`
	Offset  int         `json:"offset"`
	OrderBy PostOrderBy `json:"orderBy"`
	Order   Order       `json:"order"`
}

type GetUserInput struct {
	Limit   int         `json:"limit"`
	Offset  int         `json:"offset"`
	OrderBy UserOrderBy `json:"orderBy"`
	Order   Order       `json:"order"`
}

type LoginSession struct {
	LoginName string `json:"loginName"`
	Password  string `json:"password"`
}

type NewComment struct {
	UserID  int     `json:"userId"`
	PostID  int     `json:"postId"`
	Content *string `json:"content"`
}

type NewPost struct {
	UserID  int     `json:"userId"`
	Title   *string `json:"title"`
	Content *string `json:"content"`
}

type NewUser struct {
	LoginName string `json:"loginName"`
	Password  string `json:"password"`
}

type PostUpload struct {
	Upload graphql.Upload `json:"upload"`
	PostID int            `json:"postId"`
}

type UpdateComment struct {
	CommentID int     `json:"commentId"`
	Content   *string `json:"content"`
}

type UpdatePost struct {
	PostID  int     `json:"postId"`
	Title   *string `json:"title"`
	Content *string `json:"content"`
}

type CommentOrderBy string

const (
	CommentOrderByCommentID CommentOrderBy = "comment_id"
	CommentOrderByContent   CommentOrderBy = "content"
	CommentOrderByLike      CommentOrderBy = "like"
	CommentOrderByCreatedAt CommentOrderBy = "created_at"
	CommentOrderByUpdatedAt CommentOrderBy = "updated_at"
)

var AllCommentOrderBy = []CommentOrderBy{
	CommentOrderByCommentID,
	CommentOrderByContent,
	CommentOrderByLike,
	CommentOrderByCreatedAt,
	CommentOrderByUpdatedAt,
}

func (e CommentOrderBy) IsValid() bool {
	switch e {
	case CommentOrderByCommentID, CommentOrderByContent, CommentOrderByLike, CommentOrderByCreatedAt, CommentOrderByUpdatedAt:
		return true
	}
	return false
}

func (e CommentOrderBy) String() string {
	return string(e)
}

func (e *CommentOrderBy) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CommentOrderBy(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CommentOrderBy", str)
	}
	return nil
}

func (e CommentOrderBy) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type Order string

const (
	OrderAsc  Order = "ASC"
	OrderDesc Order = "DESC"
)

var AllOrder = []Order{
	OrderAsc,
	OrderDesc,
}

func (e Order) IsValid() bool {
	switch e {
	case OrderAsc, OrderDesc:
		return true
	}
	return false
}

func (e Order) String() string {
	return string(e)
}

func (e *Order) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = Order(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid Order", str)
	}
	return nil
}

func (e Order) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type PostOrderBy string

const (
	PostOrderByPostID    PostOrderBy = "post_id"
	PostOrderByTitle     PostOrderBy = "title"
	PostOrderByContent   PostOrderBy = "content"
	PostOrderByView      PostOrderBy = "view"
	PostOrderByLike      PostOrderBy = "like"
	PostOrderByUserID    PostOrderBy = "userId"
	PostOrderByCreatedAt PostOrderBy = "created_at"
	PostOrderByUpdatedAt PostOrderBy = "updated_at"
)

var AllPostOrderBy = []PostOrderBy{
	PostOrderByPostID,
	PostOrderByTitle,
	PostOrderByContent,
	PostOrderByView,
	PostOrderByLike,
	PostOrderByUserID,
	PostOrderByCreatedAt,
	PostOrderByUpdatedAt,
}

func (e PostOrderBy) IsValid() bool {
	switch e {
	case PostOrderByPostID, PostOrderByTitle, PostOrderByContent, PostOrderByView, PostOrderByLike, PostOrderByUserID, PostOrderByCreatedAt, PostOrderByUpdatedAt:
		return true
	}
	return false
}

func (e PostOrderBy) String() string {
	return string(e)
}

func (e *PostOrderBy) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PostOrderBy(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PostOrderBy", str)
	}
	return nil
}

func (e PostOrderBy) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type UserOrderBy string

const (
	UserOrderByUserID   UserOrderBy = "user_id"
	UserOrderByNickname UserOrderBy = "nickname"
)

var AllUserOrderBy = []UserOrderBy{
	UserOrderByUserID,
	UserOrderByNickname,
}

func (e UserOrderBy) IsValid() bool {
	switch e {
	case UserOrderByUserID, UserOrderByNickname:
		return true
	}
	return false
}

func (e UserOrderBy) String() string {
	return string(e)
}

func (e *UserOrderBy) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UserOrderBy(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid UserOrderBy", str)
	}
	return nil
}

func (e UserOrderBy) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}
