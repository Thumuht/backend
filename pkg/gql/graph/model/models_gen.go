// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package model

import (
	"fmt"
	"io"
	"strconv"

	"github.com/99designs/gqlgen/graphql"
)

type GetCommentInput struct {
	Limit   int            `json:"limit"`
	Offset  int            `json:"offset"`
	OrderBy CommentOrderBy `json:"orderBy"`
	Order   Order          `json:"order"`
}

type GetPostInput struct {
	Limit    int         `json:"limit"`
	Offset   int         `json:"offset"`
	OrderBy  PostOrderBy `json:"orderBy"`
	Order    Order       `json:"order"`
	Followed *bool       `json:"followed,omitempty"`
	Tags     *int        `json:"tags,omitempty"`
}

type GetUserInput struct {
	Limit   int         `json:"limit"`
	Offset  int         `json:"offset"`
	OrderBy UserOrderBy `json:"orderBy"`
	Order   Order       `json:"order"`
}

type LoginInfo struct {
	Token  string `json:"token"`
	UserID int    `json:"userId"`
}

type LoginSession struct {
	LoginName string `json:"loginName"`
	Password  string `json:"password"`
}

type MessageInput struct {
	ToID    int    `json:"toId"`
	Content string `json:"content"`
}

type NewComment struct {
	UserID  int     `json:"userId"`
	PostID  int     `json:"postId"`
	Content *string `json:"content,omitempty"`
}

type NewMarkPost struct {
	PostID         int `json:"postId"`
	BookmarkListID int `json:"bookmarkListId"`
}

type NewPost struct {
	UserID   int     `json:"userId"`
	Title    *string `json:"title,omitempty"`
	Content  *string `json:"content,omitempty"`
	Tag      *int    `json:"tag,omitempty"`
	Position *string `json:"position,omitempty"`
}

type NewUser struct {
	LoginName string `json:"loginName"`
	Password  string `json:"password"`
}

type PostUpload struct {
	Upload     graphql.Upload   `json:"upload"`
	ParentID   int              `json:"parentId"`
	ParentType AttachmentParent `json:"parentType"`
}

type UpdateComment struct {
	CommentID int     `json:"commentId"`
	Content   *string `json:"content,omitempty"`
}

type UpdatePost struct {
	PostID  int     `json:"postId"`
	Title   *string `json:"title,omitempty"`
	Content *string `json:"content,omitempty"`
}

type UpdateUser struct {
	Nickname *string `json:"nickname,omitempty"`
	Email    *string `json:"email,omitempty"`
	About    *string `json:"about,omitempty"`
	Avatar   *string `json:"avatar,omitempty"`
	Password *string `json:"password,omitempty"`
}

type MyTime struct {
	UnixTime  int    `json:"unixTime"`
	TimeStamp string `json:"timeStamp"`
}

type AttachmentParent string

const (
	AttachmentParentPost    AttachmentParent = "post"
	AttachmentParentComment AttachmentParent = "comment"
)

var AllAttachmentParent = []AttachmentParent{
	AttachmentParentPost,
	AttachmentParentComment,
}

func (e AttachmentParent) IsValid() bool {
	switch e {
	case AttachmentParentPost, AttachmentParentComment:
		return true
	}
	return false
}

func (e AttachmentParent) String() string {
	return string(e)
}

func (e *AttachmentParent) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AttachmentParent(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AttachmentParent", str)
	}
	return nil
}

func (e AttachmentParent) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type CommentOrderBy string

const (
	CommentOrderByCommentID CommentOrderBy = "comment_id"
	CommentOrderByContent   CommentOrderBy = "content"
	CommentOrderByLike      CommentOrderBy = "like"
	CommentOrderByCreatedAt CommentOrderBy = "created_at"
	CommentOrderByUpdatedAt CommentOrderBy = "updated_at"
)

var AllCommentOrderBy = []CommentOrderBy{
	CommentOrderByCommentID,
	CommentOrderByContent,
	CommentOrderByLike,
	CommentOrderByCreatedAt,
	CommentOrderByUpdatedAt,
}

func (e CommentOrderBy) IsValid() bool {
	switch e {
	case CommentOrderByCommentID, CommentOrderByContent, CommentOrderByLike, CommentOrderByCreatedAt, CommentOrderByUpdatedAt:
		return true
	}
	return false
}

func (e CommentOrderBy) String() string {
	return string(e)
}

func (e *CommentOrderBy) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CommentOrderBy(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CommentOrderBy", str)
	}
	return nil
}

func (e CommentOrderBy) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type Order string

const (
	OrderAsc  Order = "ASC"
	OrderDesc Order = "DESC"
)

var AllOrder = []Order{
	OrderAsc,
	OrderDesc,
}

func (e Order) IsValid() bool {
	switch e {
	case OrderAsc, OrderDesc:
		return true
	}
	return false
}

func (e Order) String() string {
	return string(e)
}

func (e *Order) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = Order(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid Order", str)
	}
	return nil
}

func (e Order) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type PostOrderBy string

const (
	PostOrderByPostID      PostOrderBy = "post_id"
	PostOrderByTitle       PostOrderBy = "title"
	PostOrderByContent     PostOrderBy = "content"
	PostOrderByView        PostOrderBy = "view"
	PostOrderByLike        PostOrderBy = "like"
	PostOrderByUserID      PostOrderBy = "userId"
	PostOrderByCreatedAt   PostOrderBy = "created_at"
	PostOrderByUpdatedAt   PostOrderBy = "updated_at"
	PostOrderByCommentsNum PostOrderBy = "comments_num"
)

var AllPostOrderBy = []PostOrderBy{
	PostOrderByPostID,
	PostOrderByTitle,
	PostOrderByContent,
	PostOrderByView,
	PostOrderByLike,
	PostOrderByUserID,
	PostOrderByCreatedAt,
	PostOrderByUpdatedAt,
	PostOrderByCommentsNum,
}

func (e PostOrderBy) IsValid() bool {
	switch e {
	case PostOrderByPostID, PostOrderByTitle, PostOrderByContent, PostOrderByView, PostOrderByLike, PostOrderByUserID, PostOrderByCreatedAt, PostOrderByUpdatedAt, PostOrderByCommentsNum:
		return true
	}
	return false
}

func (e PostOrderBy) String() string {
	return string(e)
}

func (e *PostOrderBy) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PostOrderBy(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PostOrderBy", str)
	}
	return nil
}

func (e PostOrderBy) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type UserOrderBy string

const (
	UserOrderByUserID   UserOrderBy = "user_id"
	UserOrderByNickname UserOrderBy = "nickname"
)

var AllUserOrderBy = []UserOrderBy{
	UserOrderByUserID,
	UserOrderByNickname,
}

func (e UserOrderBy) IsValid() bool {
	switch e {
	case UserOrderByUserID, UserOrderByNickname:
		return true
	}
	return false
}

func (e UserOrderBy) String() string {
	return string(e)
}

func (e *UserOrderBy) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UserOrderBy(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid UserOrderBy", str)
	}
	return nil
}

func (e UserOrderBy) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}
